/*
 * Project: dp-api-common
 * File:	QueryAssemblyTestCase.java
 * Package: com.ospreydcs.dp.jal.tools.query.assem
 * Type: 	QueryAssemblyTestCase
 *
 * Copyright 2010-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.

 * @author Christopher K. Allen
 * @org    OspreyDCS
 * @since Aug 8, 2025
 *
 */
package com.ospreydcs.dp.jal.tools.query.assem;

import java.io.PrintStream;
import java.time.Duration;
import java.time.Instant;
import java.util.Set;
import java.util.SortedSet;

import com.ospreydcs.dp.api.common.IDataTable;
import com.ospreydcs.dp.api.common.JalDataTableType;
import com.ospreydcs.dp.api.common.ResultStatus;
import com.ospreydcs.dp.api.query.DpDataRequest;
import com.ospreydcs.dp.api.query.DpQueryException;
import com.ospreydcs.dp.api.query.model.assem.DataTableCreator;
import com.ospreydcs.dp.api.query.model.assem.QueryRequestRecoverer;
import com.ospreydcs.dp.api.query.model.assem.QueryResponseAssembler;
import com.ospreydcs.dp.api.query.model.assem.SampledAggregate;
import com.ospreydcs.dp.api.query.model.coalesce.SampledBlockClocked;
import com.ospreydcs.dp.api.query.model.coalesce.SampledBlockTmsList;
import com.ospreydcs.dp.api.query.model.correl.RawClockedData;
import com.ospreydcs.dp.api.query.model.correl.RawCorrelatedData;
import com.ospreydcs.dp.api.query.model.correl.RawTmsListData;
import com.ospreydcs.dp.api.query.model.superdom.SampledBlockSuperDom;
import com.ospreydcs.dp.api.query.model.superdom.TimeDomainProcessor;
import com.ospreydcs.dp.jal.tools.query.request.TestArchiveRequestTestResult;
import com.ospreydcs.dp.jal.tools.query.testrequests.TestArchiveRequest;

/**
 * <p>
 * Record containing the parameters for a single (DP Test Archive) time-series data request assembly test case.
 * </p>
 * <p>
 * <h2>Test Archive Request Assembly</h2>
 * A Data Platform Test Archive time-series data request and assembly assembly test case involves the following:
 * <ol>
 * <li>The recovery and correlation of time-series data requests, </li>
 * <li>The super-domain processing of the recovered data into disjoint raw data blocks, </li>
 * <li>The assembly of raw data blocks into disjoint "sampled data blocks" each exposing <code>IDataTable</code>, </li>
 * <li>The aggregation of sampled data blocks into a "sampled aggregate,"</li>
 * <li>The creation of a JAL data table from the sampled aggregate.</li>
 * </ol>   
 * This record contains the parameters necessary to perform
 * a single time-series query request assembly test evaluation.
 * </p>
 * <p>
 * <h2>Operation</h2>
 * A time-series data request assembly requires the component <code>QueryRequestRecoverer</code> to recover
 * the raw request data recovery and correlation, and a <code>QueryResponseAssembler</code> component to assemble
 * the resulting raw correlated data into a sampled aggregate of disjoint sampled blocks.
 * </p>
 * <p>
 * The field <code>{@link #rqstFinal}</code> is the time-series data request to be performed
 * for the test case.  The other parameters are used to modify the request generated by field
 * <code>{@link #enmRqstOrg}</code>, the originating <code>{@link TestArchiveRquest}</code> instance
 * from which the final request is built.  The field <code>{@link #enmTblType}</code> specifies the
 * final data table type to be created from the sampled aggregate.
 * </p>
 * <p>
 * <h2>Test Case Evaluation and Results</h2>
 * A test case is evaluated using the <code>{@link #evaluate(QueryRequestRecoverer)}</code> method.  The
 * The results of a single test case are contained in a <code>{@link TestArchiveRequestTestResult}</code> record, 
 * which is returned by the method.  Considering the above, the result record contain fields for both the 
 * recovery and correlation of the raw, time-series data, and for the super-domain processing that follows.
 * </p> 
 *
 *
 * @author Christopher K. Allen
 * @since Aug 8, 2025
 *
 * @param indCase       the (optional) test case index
 * @param enmRqstOrg    the originating Test Archive data request
 * @param setSupplPvs   set of PV names supplementing the request
 * @param durRqstRange  request time range duration override
 * @param durRqstDelay  request time range delay override
 * @param rqstFinal     the final time-series data request to perform
 * 
 * @param bolAggrErrChk     enable/disable advanced error checking/verification in sampled aggregate assembly
 * @param bolAggrTmDomColl  enable/disable time-domain collisions in sampled aggregate assembly
 * @param bolAggrConcEnbl   enable/disable concurrency in sampled aggregate assembly
 * @param szAggrConcPivot   pivot size in current sampled aggregate assembly
 * @param cntAggrConcMaxThrds maximum thread count in concurrent sampled aggregate assembly
 * 
 * @param bolTblBuild       enable/disable the creation of a data table instance in the evaluation
 * @param enmTblType        the result JAL data table type to be created
 * @param bolTblStatDef     use static data table as default in automatic table type selection
 * @param bolTblStatMaxSz   enforce maximum size limit in static data table type creation
 * @param szTblStatMaxSz    the maximum size limit for static data tables
 */
public record QueryAssemblyTestCase(
        int                 indCase,
        TestArchiveRequest  enmRqstOrg,
        Set<String>         setSupplPvs,
        Duration            durRqstRange,
        Duration            durRqstDelay,
        DpDataRequest       rqstFinal,
        
        boolean             bolAggrErrChk,
        boolean             bolAggrTmDomColl,
        boolean             bolAggrConcEnbl,
        int                 szAggrConcPivot,
        int                 cntAggrConcMaxThrds,
        
        boolean             bolTblBuild,
        JalDataTableType    enmTblType,
        boolean             bolTblStatDef,
        boolean             bolTblStatMaxSz,
        long                szTblStatMaxSz
        ) 
{

    //
    // Creator
    //
    
    /**
     * <p>
     * Creates and returns a new <code>QueryAssemblyTestCase</code> record with fields given by the argument values.
     * </p>
     * <p>
     * The test case index is taken from the record resource <code>{@link #IND_CASE}</code> which is incremented in the
     * canonical constructor.
     * </p>
     * 
     * @param indCase       the (optional) test case index
     * @param enmRqstOrg    the originating Test Archive data request
     * @param setSupplPvs   set of PV names supplementing the request
     * @param durRqstRange  request time range duration override
     * @param durRqstDelay  request time range delay override
     * @param rqstFinal     the final time-series data request to perform
     * 
     * @param bolAggrErrChk     enable/disable advanced error checking/verification in sampled aggregate assembly
     * @param bolAggrTmDomColl  enable/disable time-domain collisions in sampled aggregate assembly
     * @param bolAggrConcEnbl   enable/disable concurrency in sampled aggregate assembly
     * @param szAggrConcPivot   pivot size in current sampled aggregate assembly
     * @param cntAggrConcMaxThrds maximum thread count in concurrent sampled aggregate assembly
     * 
     * @param bolTblBuild       enable/disable the creation of a data table instance in the evaluation
     * @param enmTblType        the result JAL data table type to be created
     * @param bolTblStatDef     use static data table as default in automatic table type selection
     * @param bolTblStatMaxSz   enforce maximum size limit in static data table type creation
     * @param szTblStatMaxSz   the maximum size limit for static data tables
     */
    public static QueryAssemblyTestCase from(
            TestArchiveRequest  enmRqstOrg,
            Set<String>         setSupplPvs,
            Duration            durRqstRange,
            Duration            durRqstDelay,
            DpDataRequest       rqstFinal,
            
            boolean             bolAggrErrChk,
            boolean             bolAggrTmDomColl,
            boolean             bolAggrConcEnbl,
            int                 szAggrConcPivot,
            int                 cntAggrConcMaxThrds,
            
            boolean             bolTblBuild,
            JalDataTableType    enmTblType,
            boolean             bolTblStatDef,
            boolean             bolTblStatMaxSz,
            long                szTblStatMaxSz
            )
    {
        return new QueryAssemblyTestCase(
                IND_CASE, 
                enmRqstOrg, setSupplPvs, durRqstRange, durRqstDelay, rqstFinal,
                bolAggrErrChk, bolAggrTmDomColl, bolAggrConcEnbl, szAggrConcPivot, cntAggrConcMaxThrds,
                bolTblBuild, enmTblType, bolTblStatDef, bolTblStatMaxSz, szTblStatMaxSz 
                );
    }
    
    
    //
    // Record Resources
    //
    
    /** The raw correlated data (recovered time-series request data) assembler under evaluation */
    private static final QueryResponseAssembler                PRCR_RSP_ASSMBLR = QueryResponseAssembler.create();
    
    /** The data table creator under evaluation */
    private static final DataTableCreator                       PRCR_TBL_CTOR = DataTableCreator.create();
    
    
    
    //
    // Record Attributes
    //
    
    /** Internal test case index (counter) */
    private static          int IND_CASE = 1;
    
    //
    // Constructors
    //
    
    /**
     * <p>
     * Constructs a new <code>QueryAssemblyTestCase</code> instance.
     * </p>
     * <p>
     * Canonical constructor - sets field values then increments class variable <code>{@link #IND_CASE}</code>.
     * </p> 
     *
     * @param indCase       the (optional) test case index
     * @param enmRqstOrg    the originating Test Archive data request
     * @param setSupplPvs   set of PV names supplementing the request
     * @param durRqstRange  request time range duration override
     * @param durRqstDelay  request time range delay override
     * @param rqstFinal     the final time-series data request to perform
     * 
     * @param bolAggrErrChk     enable/disable advanced error checking/verification in sampled aggregate assembly
     * @param bolAggrTmDomColl  enable/disable time-domain collisions in sampled aggregate assembly
     * @param bolAggrConcEnbl   enable/disable concurrency in sampled aggregate assembly
     * @param szAggrConcPivot   pivot size in current sampled aggregate assembly
     * @param cntAggrConcMaxThrds maximum thread count in concurrent sampled aggregate assembly
     * 
     * @param enmTblType    the result JAL data table type to be created
     */
    public QueryAssemblyTestCase {
        IND_CASE++;
    }
    
    
    //
    // Operations
    //
    
    /**
     * <p>
     * Performs the current test using the test conditions described in the record fields.
     * </p>
     * <p>
     * <h2>NOTES:</h2>
     * If the test fails (i.e., an exception is thrown during the evaluation procedure) the
     * field <code>{@link QueryAssemblyTestResult#recTestStatus()}</code> contains a 
     * failure message and cause.  The remaining fields will be undefined.
     * </p>
     * 
     * @param prcrRcvr  the request recoverer and correlator used to get the time-series data
     * 
     * @return  the results of the test evaluation as a <code>QueryAssemblyTestResult</code> record
     */
    public QueryAssemblyTestResult  evaluate(QueryRequestRecoverer prcrRcvr) {
        
        // Create the request ID string
        String      strRqstId = this.enmRqstOrg.name();
        if (!this.setSupplPvs.isEmpty())
            strRqstId += " + " + this.setSupplPvs;
        
        try {

            //
            // --- Raw Data Recovery/Correlation ---
            //

            // Recover and correlate the raw time-series, recording the performance parameters
            Instant     insStart = Instant.now();
            SortedSet<RawCorrelatedData>  setRawData = prcrRcvr.processRequest(rqstFinal); // throws DpQueryException
            Instant     insFinish = Instant.now();

            // Collect the results
            Duration    durDataRawPrcd = Duration.between(insStart, insFinish);
            long        szAllocRawPrcd = prcrRcvr.getProcessedByteCount();
            double      dblRateRawPrcd = ( ((double)szAllocRawPrcd) * 1000.0 )/durDataRawPrcd.toNanos();

            int         cntRcvrdMsgs = prcrRcvr.getProcessedMessageCount();
            int         cntBlksRawTot = setRawData.size();
            int         cntBlksRawClkd = setRawData.stream().filter(blk -> blk instanceof RawClockedData).mapToInt(blk -> 1).sum();
            int         cntBlksRawTmsLst = setRawData.stream().filter(blk -> blk instanceof RawTmsListData).mapToInt(blk -> 1).sum();

            // Inspect raw data for ordering and collisions
            ResultStatus    recBlksRawOrdered = TimeDomainProcessor.verifyStartTimeOrdering(setRawData);
            ResultStatus    recBlksRawDisTmDom = TimeDomainProcessor.verfifyDisjointTimeDomains(setRawData);


            //
            // --- Sampled Aggregate Assembly ---
            //

            // Configure the sampled aggregate assembler
            this.configureAssembler(PRCR_RSP_ASSMBLR);

            // Assemble the sampled aggregate from the raw correlated data, recording performance parameters
            insStart = Instant.now();
            SampledAggregate blksAgg = PRCR_RSP_ASSMBLR.process(strRqstId, setRawData); // throws DpQueryException
            insFinish = Instant.now();

            // Collect the results
            Duration    durAggrAssm = Duration.between(insStart, insFinish);
            long        szAllocAggrAssm = blksAgg.getRawAllocation();
            double      dblRateAggAssm = ( ((double)szAllocAggrAssm) * 1000.0 )/durAggrAssm.toNanos();

            int         cntBlksAggTot = blksAgg.getSampledBlockCount();
            int         cntBlksAggClkd = blksAgg.stream().filter(blk -> blk instanceof SampledBlockClocked).mapToInt(blk -> 1).sum();
            int         cntBlksAggTmsLst = blksAgg.stream().filter(blk -> blk instanceof SampledBlockTmsList).mapToInt(blk -> 1).sum();
            int         cntBlksAggSupDom = blksAgg.stream().filter(blk -> blk instanceof SampledBlockSuperDom).mapToInt(blk -> 1).sum();


            //
            // --- Data Table Creation ---
            //

            // Configure the table creator
            this.configureTableCreator(PRCR_TBL_CTOR);

            // Create the data table
            insStart = Instant.now();
            IDataTable table = PRCR_TBL_CTOR.createTable(blksAgg, szAllocAggrAssm); // throws DpQueryException
            insFinish = Instant.now();

            // Collect the results
            Duration            durTblBld = Duration.between(insStart, insFinish);
            JalDataTableType    enmTblType = table.getTableType();
            long                szTblCalc = table.allocationSize();
            int                 cntTblRows = table.getRowCount();
            int                 cntTblCols = table.getColumnCount();
            String              strTblId = table.getRequestId();
            double              dblRateTblBld = ( ((double)szTblCalc) * 1000.0 )/durTblBld.toNanos();


            //
            // --- Request Processing Totals ---
            //

            long        szAllocTotal = szTblCalc;
            Duration    durTotal = durDataRawPrcd.plus(durAggrAssm).plus(durTblBld);
            double      dblRateTot = ( ((double)szAllocTotal) * 1000.0)/durTotal.toNanos();

            // Create the test result record and return it
            QueryAssemblyTestResult recResult = QueryAssemblyTestResult.from(
                    strRqstId, ResultStatus.SUCCESS,
                    cntRcvrdMsgs, szAllocRawPrcd, durDataRawPrcd, dblRateRawPrcd, 
                    cntBlksRawTot, cntBlksRawClkd, cntBlksRawTmsLst, recBlksRawOrdered, recBlksRawDisTmDom, 
                    durAggrAssm, dblRateAggAssm, szAllocAggrAssm, cntBlksAggTot, cntBlksAggClkd, cntBlksAggTmsLst, cntBlksAggSupDom, 
                    strTblId, durTblBld, dblRateTblBld, enmTblType, szTblCalc, cntTblRows, cntTblCols, 
                    szAllocTotal, durTotal, dblRateTot, 
                    this);

            return recResult;

            // Test Failure
        } catch (DpQueryException e) {
            String          strErrMsg = e.getCause().getMessage();
            ResultStatus    recStatus = ResultStatus.newFailure(strErrMsg, e);

            QueryAssemblyTestResult recResult = QueryAssemblyTestResult.from(strRqstId, recStatus, this);

            return recResult;
        }
    }
    
    /**
     * <p>
     * Prints out a text description of the record fields to the given output stream.
     * </p>
     * <p>
     * A line-by-line text description of each record field is written to the given output.
     * The <code>strPad</code> is used to supply an optional whitespace character padding to the
     * left-hand side header for each line description.
     * </p>
     *   
     * @param ps        output stream to receive text description of record fields
     * @param strPad    white-space padding for each line header (or <code>null</code>)
     */
    public void printOut(PrintStream ps, String strPad) {
        if (strPad == null)
            strPad = "";
        String  strPadd = strPad + "  ";
        String  strPaddBul = strPadd + " - ";
        
        ps.println(strPad + this.getClass().getSimpleName() + " " + this.indCase + ":");
        
        ps.println(strPadd + "Original Data Request ID          : " + this.enmRqstOrg.name());
        ps.println(strPadd + "Request duration override         : " + this.durRqstRange);
        ps.println(strPadd + "Request delay override            : " + this.durRqstDelay);
        ps.println(strPadd + "  Supplemental PV names");
        this.setSupplPvs.forEach(str -> ps.println(strPaddBul + str));
        
        ps.println(strPadd + "Sampled Aggregate Assembly");
        ps.println(strPadd + "  advanced error checking enabled : " + this.bolAggrErrChk);
        ps.println(strPadd + "  time-domain collisions enabled  : " + this.bolAggrTmDomColl);
        ps.println(strPadd + "  concurrent processing enabled   : " + this.bolAggrConcEnbl);
        ps.println(strPadd + "  concurrency pivot size          : " + this.szAggrConcPivot);
        ps.println(strPadd + "  concurrency max. thread count   : " + this.cntAggrConcMaxThrds);
        
        ps.println(strPadd + "Time-Series Data Table Creation");
        ps.println(strPadd + "  result JAL table type           : " + this.enmTblType);
        ps.println(strPadd + "  static table default enabled    : " + this.bolTblStatDef);
        ps.println(strPadd + "  static table max. size enabled  : " + this.bolTblStatMaxSz);
        ps.println(strPadd + "  static data table maximum size  : " + this.szTblStatMaxSz);
    }

    
    //
    // Support Methods
    //
    
    /**
     * <p>
     * Configures the given <code>SampledAggregate</code> instance to the conditions of this test case.
     * </p>
     * <p>
     * The configuration process uses the following fields:
     * <ul>
     * <li><code>{@link #bolAggrErrChk}</code></li>
     * <li><code>{@link #bolAggrTmDomColl}</code></li>
     * <li><code>{@link #bolAggrConcEnbl}</code></li>
     * <li><code>{@link #szAggrConcPivot}</code></li>
     * <li><code>{@link #cntAggrConcMaxThrds}</code></li>
     * </ul>
     * </p>
     * 
     * @param prcrAssmblr   the assembler processor to be configured
     */
    private void    configureAssembler(QueryResponseAssembler prcrAssmblr) {
        
        prcrAssmblr.enableAdvancedErrorChecking(this.bolAggrErrChk);
        prcrAssmblr.enableTimeDomainCollisions(this.bolAggrTmDomColl);
        prcrAssmblr.enableConcurrency(this.bolAggrConcEnbl);
        prcrAssmblr.setConcurrencyPivotSize(this.szAggrConcPivot);
        prcrAssmblr.setMaxThreadCount(this.cntAggrConcMaxThrds);
    }
    
    /**
     * <p>
     * Configures the given <code>DataTableCreator</code> instance to the conditions of this test case.
     * </p>
     * <p>
     * The configuration process uses the following fields:
     * <code>
     * <ul>
     * <li>{@link #enmTblType}</li>
     * <li>{@link #bolTblStatDef}</li>
     * <li>{@link #bolTblStatMaxSz}</li>
     * <li>{@link #szTblStatMaxSz}</li>
     * </ul>
     * </code>
     * </p>
     * 
     * @param prcrCtor  the data table creator to be configured
     */
    private void    configureTableCreator(DataTableCreator prcrCtor) {
        
        prcrCtor.setTableType(this.enmTblType);
        prcrCtor.enableStaticTableDefault(this.bolTblStatDef);
        prcrCtor.enableStaticTableMaxSize(this.bolTblStatMaxSz);
        prcrCtor.setStaticTableMaxSize(this.szTblStatMaxSz);
    }
    
//    /**
//     * <p>
//     * Creates the <code>IDataTable</code> concrete instance based upon the test case conditions.
//     * </p>
//     * 
//     * @param blksAggr  source of the table data
//     * 
//     * @return  a <code>IDataTable</code> implementation created from the argument and the test case conditions
//     * 
//     * @throws CompletionException
//     */
//    private IDataTable  createTable(SampledAggregate blksAggr) throws CompletionException {
//
//        // Get the source data size
//        long    szData = blksAggr.computeAllocationSize();
//
//        // Dynamic data table type
//        if (this.enmTblType == JalDataTableType.DYNAMIC)
//            return blksAggr.createDynamicDataTable();
//        
//        // Static data table
//        if (this.enmTblType == JalDataTableType.STATIC) {
//            if (!this.bolTblStatMaxSz)
//                return blksAggr.createStaticDataTable();
//            
//            if (szData < this.szTblStatMaxSz)
//                return blksAggr.createStaticDataTable();
//
//            String strMsg = JavaRuntime.getQualifiedMethodNameSimple() 
//                    + " - Table creation failed." 
//                    + " Maximum static table size enabled and sampled aggregate size " + szData 
//                    + " is larger than maximum static table size " + this.szTblStatMaxSz;
//
//            throw new CompletionException(strMsg, new Throwable());
//        }
//        
//        // Automatic data table type
//        if (this.enmTblType == JalDataTableType.AUTO) {
//            if (this.bolTblStatDef && (szData < this.szTblStatMaxSz)) 
//                return blksAggr.createStaticDataTable();
//            else 
//                return blksAggr.createDynamicDataTable();
//        }
//        
//        // Unsupported type
//        String  strMsg = JavaRuntime.getQualifiedMethodNameSimple()
//                + " - Table creation failed."
//                + " Unsupported table type " + this.enmTblType;
//        
//        throw new CompletionException(strMsg, new Throwable());
//    }
}
