/*
 * Project: dp-api-common
 * File:	SuperDomTestCase.java
 * Package: com.ospreydcs.dp.jal.tools.query.superdom
 * Type: 	SuperDomTestCase
 *
 * Copyright 2010-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.

 * @author Christopher K. Allen
 * @org    OspreyDCS
 * @since Jun 15, 2025
 *
 */
package com.ospreydcs.dp.jal.tools.query.superdom;

import java.io.PrintStream;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.SortedSet;

import com.ospreydcs.dp.api.common.ResultStatus;
import com.ospreydcs.dp.api.common.TimeInterval;
import com.ospreydcs.dp.api.query.DpDataRequest;
import com.ospreydcs.dp.api.query.DpQueryException;
import com.ospreydcs.dp.api.query.model.assem.QueryRequestRecoverer;
import com.ospreydcs.dp.api.query.model.correl.RawClockedData;
import com.ospreydcs.dp.api.query.model.correl.RawCorrelatedData;
import com.ospreydcs.dp.api.query.model.correl.RawTmsListData;
import com.ospreydcs.dp.api.query.model.superdom.RawSuperDomData;
import com.ospreydcs.dp.api.query.model.superdom.TimeDomainProcessor;
import com.ospreydcs.dp.jal.tools.query.request.TestArchiveRequest;

/**
 * <p>
 * Record containing the parameters for a single Super Domain Evaluation test case.
 * </p>
 * <p>
 * <h2>Super Domain Test</h2>
 * A super domain test case involves both the recovery and correlation of time-series data requests,
 * and the super-domain processing that follows.  This record contains the parameters necessary to perform
 * a single super-domain test evaluation.
 * </p>
 * <p>
 * The field <code>{@link #rqstFinal}</code> is the time-series data request to be performed
 * for the test case.  The other parameters are used to modify the request generated by field
 * <code>{@link #enmRqstOrg}</code>, the originating <code>{@link TestArchiveRquest}</code> instance
 * from which the final request is built.
 * </p>
 * <p>
 * <h2>Test Case Evaluation and Results</h2>
 * A test case is evaluated using the <code>{@link #evaluate(QueryRequestRecoverer)}</code> method.  The
 * The results of a single test case are contained in a <code>{@link SuperDomTestResult}</code> record, which
 * is returned by the method.  Considering the above, the result record contain fields for both the 
 * recovery and correlation of the raw, time-series data, and for the super-domain processing that follows.
 * </p> 
 *
 * @author Christopher K. Allen
 * @since Jun 15, 2025
 *
 * @param enmRqstOrg    the originating Test Archive data request
 * @param setPvNames    set of PV names supplementing the request
 * @param durRange      request time range duration override
 * @param durDelay      request time range delay override
 * @param rqstFinal     the final time-series data request to perform
 */
public record SuperDomTestCase(
        int                 indCase,
        TestArchiveRequest  enmRqstOrg,
        Set<String>         setPvNames,
        Duration            durRange,
        Duration            durDelay,
        DpDataRequest       rqstFinal
        ) 

{
    
    //
    // Creator
    //
    
    /**
     * <p>
     * Creates and returns a new <code>SuperDomTestCase</code> record with fields given by the argument valuees.
     * </p>
     * 
     * @param enmRqstOrg    the originating Test Archive data request
     * @param setPvNames    set of PV names supplementing the request
     * @param durRange      request time range duration override
     * @param durDelay      request time range delay override
     * @param rqstFinal     the final time-series data request to perform
     * 
     * @return  a new <code>SuperDomTestCase</code> record populated with the given values  
     */
    public static final SuperDomTestCase    from(
            TestArchiveRequest  enmRqstOrg,
            Set<String>         setPvNames,
            Duration            durRange,
            Duration            durDelay,
            DpDataRequest       rqstFinal
            )
    {
        return new SuperDomTestCase(IND_CASE, enmRqstOrg, setPvNames, durRange, durDelay, rqstFinal);
    }

    
    //
    // Record Resources
    //
    
    /** Internal test case index (counter) */
    private static          int IND_CASE = 1;
    
    
    /** The time-domain collision processor */
    private static final TimeDomainProcessor    PROC_TM_DOM = TimeDomainProcessor.create();

    
    //
    // Constructors
    //
    
    /**
     * <p>
     * Constructs a new <code>QueryChannelTestCase</code> instance.
     * </p>
     * <p>
     * Canonical constructor.  Sets field values and increments record index counter <code>{@link #IND_CASE}</code>
     * </p>
     *
     * @param indCase     the test case index
     * @param enmRqstOrg    the originating Test Archive data request
     * @param setPvNames    set of PV names supplementing the request
     * @param durRange      request time range duration override
     * @param durDelay      request time range delay override
     * @param rqstFinal     the final time-series data request to perform
     */
    public SuperDomTestCase {
        IND_CASE++;
    }
    
    
    
    //
    // Operations
    //
    
    /**
     * <p>
     * Evaluates this test case using the given <code>QueryRequestProcessor</code> .
     * </p>
     * <p>
     * The test case data recovery described by this record is performed on the given <code>QueryRequestProcessor</code>.
     * The recovered data is then assembled into super domains and inspected.
     * The performance of the evaluation is measured and returned as a <code>SuperDomTestResult</code> record.
     * </p>
     * <p>
     * <h2>Evaluation</h2>
     * There are essentially two operation within a <code>SuperDomTestCase</code>: 
     * <ol>
     * <li>Recovery and correlation of the time-series data request.</li>
     * <li>Super domain processing of the correlated data.</li>
     * </ol>
     * The recovery and correlation recovers all raw data from the Query Service as <code>QueryData</code>
     * Protocol Buffers messages, then correlates the data by timestamps.  That is, all data belonging to
     * a set of timestamps (either a sample clock or an explicit timestamp list) is identified and assigned
     * to the timestamps.
     * </p>
     * <p>
     * The super domain processing inspects the timestamps of all correlated data for time-domain collisions.
     * Time-domain collisions are typically caused by process variables sampled during the same time interval
     * but with different sample periods.  The super domain processor identifies all correlated data with time-domain
     * collisions and separates them into "super domains."  The remaining correlated data (i.e., without collisions
     * is left as is.  The result is a collection of data with disjoint time domains, either standard timestamped
     * domains, or super domains.
     * </p>
     * <p>
     * The super-domain processing rate is computed in "blocks per second" and returned in the field
     * <code>{@link SuperDomTestResult#dblRateSupDomPrcd()}</code>.  It is the number of raw, correlated data
     * blocks given to the <code>TimeDomainProcessor</code> divided by the time taken for processing,
     * or <code>{@link SuperDomTestResult#cntRawBlksTotal()}</code> / <code>{@link SuperDomTestResult#durSupDomPrcd()}</code>. 
     * </p> 
     * <p>
     * <h2>NOTES:</h2>
     * <ul>
     * <li>
     * <s>
     * The super-domain processing rate is computed in "blocks per second" and returned in the field
     * <code>{@link SuperDomTestResult#dblRateSupDomPrcd()}</code>.
     * </s>   
     * </li>
     * </ul>
     * </p>
     * 
     * @param prcrRqst  the request processor used to recover and correlate the time-series data request within the test case
     * 
     * @return  the results of this test case performance evaluation
     * 
     * @throws DpQueryException         general exception during data recovery (see message and cause)
     * @throws IllegalStateException    internal processing error: attempt to process super domain when none available
     * @throws IndexOutOfBoundsException internal processing error: attempt to access index beyond end of processing list
     */
    public SuperDomTestResult   evaluate(QueryRequestRecoverer prcrRqsts) 
            throws DpQueryException, IllegalStateException, IndexOutOfBoundsException {

        // Perform timed data recovery
        Instant insStart = Instant.now();
        SortedSet<RawCorrelatedData> setRawData = prcrRqsts.processRequest(this.rqstFinal); // throws DpQueryException
        Instant insFinish = Instant.now();
        
        String  strRqstId = prcrRqsts.getRequestId();
        int     cntRecoveryMsgs = prcrRqsts.getProcessedMessageCount();
        long    szRecovery = prcrRqsts.getProcessedByteCount();
        
        int     cntBlksTot = setRawData.size();
        int     cntBlksClked = setRawData.stream().filter(data -> data instanceof RawClockedData).mapToInt(data -> 1).sum();
        int     cntBlksTmsLst = setRawData.stream().filter(data -> data instanceof RawTmsListData).mapToInt(data -> 1).sum();
        
        // Recover/Compute performance parameters
        Duration    durRecovery = Duration.between(insStart, insFinish);
        double      dblRateRecovery = ( ((double)szRecovery) * 1000 )/durRecovery.toNanos();

        // Inspect raw data for ordering and collisions
        ResultStatus    recOrdering = TimeDomainProcessor.verifyStartTimeOrdering(setRawData);
        ResultStatus    recDisTmDom = TimeDomainProcessor.verfifyDisjointTimeDomains(setRawData);
        
        // Perform timed super domain processing
        insStart = Instant.now();
        PROC_TM_DOM.process(setRawData);
        insFinish = Instant.now();
        
        List<RawCorrelatedData> lstRawData = PROC_TM_DOM.getDisjointRawData();
        List<RawSuperDomData>   lstSupData = PROC_TM_DOM.getSuperDomainData();

        // Recover/compute performance parameters
        Duration    durProcd = Duration.between(insStart, insFinish);
        double      dblRateProcd = ( ((double)szRecovery) * 1.0e9 )/durProcd.toNanos(); 
        
        // Inspect time domains
        int         cntDisRawBlks = lstRawData.size();
        int         cntDisSupBlks = lstSupData.size();
        int         cntDisBlksTot = cntDisRawBlks + cntDisSupBlks;
        
        List<TimeInterval>  lstRawDoms = lstRawData.stream().<TimeInterval>map(RawCorrelatedData::getTimeRange).toList();
        List<TimeInterval>  lstSupDoms = lstSupData.stream().<TimeInterval>map(RawSuperDomData::timeRange).toList();

        ResultStatus        recDisBlkDoms = SuperDomTestCase.checkTimeDomains(lstRawDoms, lstSupDoms);
        
        // Create test case and return
        SuperDomTestResult  recResult = SuperDomTestResult.from(strRqstId, 
                cntRecoveryMsgs, 
                szRecovery, 
                cntBlksTot, 
                cntBlksClked, 
                cntBlksTmsLst, 
                durRecovery, 
                dblRateRecovery, 
                recOrdering, 
                recDisTmDom, 
                cntDisBlksTot,
                cntDisRawBlks, 
                cntDisSupBlks, 
                recDisBlkDoms,
                durProcd, 
                dblRateProcd, 
                lstRawDoms, 
                lstSupDoms, 
                this);

        return recResult;
    }
    
    /**
     * <p>
     * Prints out a text description of the record fields to the given output stream.
     * </p>
     * <p>
     * A line-by-line text description of each record field is written to the given output.
     * The <code>strPad</code> is used to supply an optional whitespace character padding to the
     * left-hand side header for each line description.
     * </p>
     *   
     * @param ps        output stream to receive text description of record fields
     * @param strPad    white-space padding for each line header (or <code>null</code>)
     */
    public void printOut(PrintStream ps, String strPad) {
        if (strPad == null)
            strPad = "";
        
        ps.println(strPad + this.getClass().getSimpleName() + " #" + this.indCase + ":");
        ps.println(strPad + "  Test Archive request ID   : " + this.enmRqstOrg.name());
        ps.println(strPad + "  Time-series request ID    : " + this.rqstFinal.getRequestId());
        ps.println(strPad + "  Supplemental PV names     : " + this.setPvNames);
        ps.println(strPad + "  Request duration override : " + this.durRange);
        ps.println(strPad + "  Request delay override    : " + this.durDelay);
    }
    

    //
    // Support Methods
    //
    
    /**
     * <p>
     * Checks for intersecting <code>TimeInterval</code> instances within all the given arguments.
     * </p>
     * 
     * @param lstRawDoms   container of raw correlated data <code>TimeInterval</code> instances to be checked
     * @param lstSupDoms   container of super domain raw data <code>TimeInterval</code> instances to be checked
     * 
     * @return  <code>{@link ResultStatus#SUCCESS}</code> if no intersections,
     *          otherwise a failure status with message
     */
    private static ResultStatus checkTimeDomains(List<TimeInterval> lstRawDoms, List<TimeInterval> lstSupDoms) {
        
        // Internal type
        record      Pair(TimeInterval t1, TimeInterval t2)  {
            
            @Override
            public String  toString() {
                return t1.toString() + "/\\" + t2.toString();
            }
        };
        
        // Container of intersecting time intervals
        List<Pair>  lstPairs = new LinkedList<>();

        // Create the container of all time domains
        ArrayList<TimeInterval>     lstAllDoms = new ArrayList<>(lstRawDoms.size() + lstSupDoms.size());
        lstAllDoms.addAll(lstRawDoms);
        lstAllDoms.addAll(lstSupDoms);
        
        // Iterate through all time intervals looking for intersections
        Iterator<TimeInterval>  itrTgt = lstAllDoms.iterator();
        while (itrTgt.hasNext()) {
            TimeInterval    tvlTgt = itrTgt.next();

            // Check if there are no more comparisons
            if (!itrTgt.hasNext())
                break;
            
            // Compare the reset of the intervals in the list
            int                         indTgt = lstAllDoms.indexOf(tvlTgt);
            ListIterator<TimeInterval>  itrCmp = lstAllDoms.listIterator(indTgt + 1);
            while (itrCmp.hasNext()) {
                TimeInterval tvlCmp = itrCmp.next();
                
                if (tvlTgt.hasIntersectionClosed(tvlCmp)) {
                    Pair    pair = new Pair(tvlTgt, tvlCmp);
                    
                    lstPairs.add(pair);
                }
            }
        }
        
        // If no intersections occurred return SUCCESS
        if (lstPairs.isEmpty())
            return ResultStatus.SUCCESS;
        
        // Return a FAILURE status indicating intersecting time domains
        String          strMsg = "Intersecting time-domain pairs: " + lstPairs;
        ResultStatus    recFail = ResultStatus.newFailure(strMsg);
        
        return recFail;
    }
}
